#include <stdio.h>
#include <stdlib.h>

//================================================
// Ранее для хранения большого числа однотипных
// элементов мы использовали только массив.
//
// Плюс массива: очень быстрый доступ по номеру элемента.
//  (поскольку начало массива известно, а дальше все
//   элементы расположены последовательно
//   То есть (адрес элемента i) = start_address + i * sizeof(data_type)
//  )
// Однако допустим мы хотим удалить второй элемент в массиве:
//                        /-----------/
//                        v
// float array[] = {0.1, 2.1, 4.1, 6.1, 8};
// Тогда потребуется все элементы массива после второго сдвинуть
// на единицу влево.
// Причём для такого малого массива это довольно не критично,
// но затраты процессорного времени будут очень большие, если
// в массиве содержатся миллионы символов.
//------------------------------------------------
// Для таких случаев (когда часто нужно добавлять/удалять элементы)
// пригождается структура данных List (список)
//

// Определяется отдельный узел списка (аналогично одному элементу массива)
struct Node
{
    float value;       // Значение, хранящееся в данном узле списка
    struct Node* next; // Указатель на следующий узел списка
};
typedef struct Node Node;

int main()
{
    // Заполняем тестовый список из трёх узлов
    Node n1;
    n1.value = 0.1;
    Node n2;
    n2.value = 0.2;
    Node n3;
    n3.value = 0.3;
    // Ставим указатели next, чтобы связать узлы списка между собой
    n1.next = &n2;
    n2.next = &n3;
    n3.next = 0;  // У последнего элемента next должен быть равен нулю,
                  // иначе мы никак не узнаем, где конец списка
    // Выводим значения списка
    int i = 0;
    Node* n_ptr = &n1;
    while (n_ptr != 0) // продолжать цикл до конца списка
    {
        printf("List item %d = %f\n", i, n_ptr->value);
        i = i + 1;
        // Перейти от текущего узла списка к следующему.
        n_ptr = n_ptr->next;
    }

    // Создадим список и заполним его
    // элементами {0.1, 2.1, 4.1, 6.1, 8};
    //
    float array[] = { 0.1, 2.1, 4.1, 6.1, 8 };
    Node* node_ptr;

    Node* prev = 0; // предыдущий узел списка
    Node* head = 0; // голова (первый узел) списка
    for (i = 0; i < 5; i++)
    {
        // Создаём пять узлов списка для пяти элементов в массиве
        node_ptr = (Node*)malloc(sizeof(Node));
        node_ptr->value = array[i];
        // Важно, чтобы next сначала указывал на 0,
        // иначе там может по умолчанию оказаться мусор,
        // в результате мы перейдём на неправильный адрес в памяти.
        node_ptr->next = 0;

        // Если это не первый узел, ставим на него указатель next
        // от предыдущего узла
        if (prev != 0)
        {
            prev->next = node_ptr;
        }
        // Если это самый первый элемент, то задаём голову списка
        if (head == 0)
        {
            // Записываем первый узел списка
            head = node_ptr;
        }
        prev = node_ptr;
    }

    printf("=======\n\n\n");
    n_ptr = head;
    i = 0;
    while (n_ptr != 0) // продолжать цикл до конца списка
    {
        printf("List item %d = %f\n", i, n_ptr->value);
        i = i + 1;
        // Перейти от текущего узла списка к следующему.
        n_ptr = n_ptr->next;
    }

    //======
    // Получение n-го элемента списка.
    int n = 4; // Хотим получить 5-ый элемент списка (нумерация с нуля).

    n_ptr = head; // Ставим Node* n_ptr как указатель на голову списка
    for (i = 0; i < n; i++)
    {
        // Перейти от текущего узла списка к следующему.
        n_ptr = n_ptr->next;
    }

    printf("==\n\n\n");
    printf("Element #%d = %f\n", n, n_ptr->value);
    printf("==\n\n\n");

    //======
    // Чтобы удалить третий элемент из списка, достаточно сделать вот так:
    Node* n3_ptr = head->next->next;
    // Меняем указатель next, чтобы от второго узла списка сразу перескакивать
    // к четвёртому.
    (head->next)->next = head->next->next->next;
    //                   ^^^^^^^^^^^^^^^^^^^^^^^
    //                   четвёртый элемент (можно также n3_ptr->next)
    // 
    // (head->next)->next = ... // -- скобки не нужны, просто добавлены для наглядности
    //  ^^^^^^^^^^
    //  второй элемент, у него меняем, куда указывает next

    free(n3_ptr);
    // Всё, удаление завершено.

    // Таким образом, для удаления узла списка, если известен
    // указатель к этому и к предыдущему узлу, потребуется
    // всего две операции (присваивание и free(..))


    // Поэтому различные структуры для хранения данных (контейнеры)
    // обычно приводятся в таблице по оценке быстродействия
    // различных их операций.
    // И для оценки быстродействия используется O(..) - символика
    //
    // O(1) -- операция выполняется за константное время, не зависит от числа элементов
    // O(N) -- операция выполняется за const * N секунд
    // O(N^2), O(N^3), ...
    // O(log_2 N) -- const * log2(N) секунд
    // O(2^N) -- очень медленно,
    // O(N!)  -- как правило самые медленные алгоритмы
    //
    // К примеру, быстродействие сортировки пузырьком == O(N^2)
    // Быстродействие сортировки Quicksort == O( N * log_2 (N) )

    // См. week07.1.pdf
}
